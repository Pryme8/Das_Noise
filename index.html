<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Pryme8's Noise Functions</title>


<link href="./css/main.css" rel="stylesheet" type="text/css" />

<script type="text/javascript" src="./js/jquery.js"></script>
<script type="text/javascript" src="./js/dN.1.2.1.js"></script>
<script type="text/javascript" src="./js/main.js"></script>

</head>
<body>
<div class='wrap-fix'>
<div class='page-wrap'>
<div class='header'>
<h1><span><img src="imgs/logo1.png" /></span>Das Noise!</h1>
<h2>A Javascript Noise Library</h2>

<span class='head-menu'><a href='http://github.com/Pryme8/Das_Noise'>git-hub</a> | Examples | <a href='#docs'>Documentation</a> | Downloads | Editor</span>
</div>

<BR />
<div class='content'>

<div class='content-item'>This is a project to get all the fancy noises out there under one roof... I was getting super annoyed having to call different noises with different constructors, so I figured lets make this conform to my head.&nbsp;&nbsp;Most are based off of others public examples I'll make sure to credit them, but for the most part this is a whole new reworking.&nbsp;&nbsp;Quite a few bugs for right now, and Im sure the way doing the seed calculations is pretty hacky... Umm a few of the calculations are my own so my bad if they syck?&nbsp;&nbsp;Once the project is done, there will be a ton of different ways to generate noise, and I will be porting a bunch of GLSL noises I did over as well along with my Worley System and others that I can find.<BR /><BR />
A Bunch of Noises and functions are turned off for now, while I make changes to the script, currently active: Simple2D, Simple3D, Perlin2D, Perlin3D<BR />
</div>
<hr />

<div class='content-item'>
	<div class='left-menu' id='docs'>
		<div class='menu'>
<h2>Library Contents:</h2>
<h3><a href='#noise-types' >Noise Types</a></h3>
<ul>
<li><a href='#Simple2D' >Simple 2D</a></li>
<li><a href='#Simple3D'>Simple 3D</a></li>
<li><a href='#Perlin2D'>Perlin 2D</a></li>
<li><a href='#Perlin3D'>Perlin 3D</a></li>
<li><a href='#Poorly2D'>Poorly 2D</a></li>
<li><a href='#Tiley2D'>Tiley 2D</a></li>
<li><a href='#Worley2D'>Worley 2D</a></li>
</ul>
<h3><a href='#mix-types'>Mixing Types</a></h3>
<ul>
<li><a href='mix-Mix' >Mix</a></li>
<li><a href='#mix-Multiply'>Multiply</a></li>
<li><a href='#mix-Divide'>Divide</a></li>
<li><a href='#mix-Average_Add'>Average_Add</a></li>
<li><a href='#mix-Average_Sub'>Average_Sub</a></li>
</ul>
</div>
<div class='menu-section'>

<div class='section active' id='home'>
	<div class='content-item'>
<pre title="Basic Noise:"><xmp>var noise = new dN(type => string ,seed => string, args => {});
noise.getValue(args =>{});
</xmp></pre>
	</div>
</div>

<div class='section' id='Simple2D'>
<div class='content-item'>
<pre title="Simple2D:"><xmp>var noise = new dN('Simple2' ,seed => string, args => {});
noise.getValue(args =>{});
</xmp></pre>
	This is the quickest to compute, and is based off of Stefan Gustavson Noise Calculations.
	</div>
    <hr />
    <h4>Arguments</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>frequency</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>frequency refers to the period or phase at which data is sampled.</span>
    </div>
    <div class='item'>
    <span class='title'>amplitude</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>amplitude refers to the range that the current octave at which the result can be in.</span>
    </div>
    <div class='item'>
    <span class='title'>octave</span>
    <span class='types'>oftype === int >= 1</span>
    <span class='description'>Each octave has less influence on the final result. Each octave adds a linear increase in code execution time, do not use more than a few octaves if not preprocessed.</span>
    </div>
    <div class='item'>
    <span class='title'>persistence</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>The influence should each successive octave have, quantitatively.</span>
    </div>
    <div class='item'>
    <span class='title'>scale</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>This will Multipy the x,y input on the ._getValue() method.  Effectivly sizing up the noise. *A scale of 1 is effectivly random noise</span>
    </div>
    <div class='item'>
    <span class='title'>scaleFloor</span>
    <span class='types'>oftype === bool</span>
    <span class='description'>Floors the scaling of the noise to whole numbers.  This is good for a pixlated look.</span>
    </div>
    <div class='item'>
    <span class='title'>output</span>
    <span class='types'>oftype === {type: oftype === (string => 'number' || 'color' ), values: oftype === (Array(4) => [0<=>1,0<=>1,0<=>1,0<=>1])}</span>
    <span class='description'>In order to change the output from a single value to a color you must include this object as and argument.  If you are simply returning a value do not worry about this argument.  If you do include it the value array is structured as R,G,B,A and their return value will be multiplied by the respective value.</span>
    </div>
    </div>
    <h4>Methods</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>._getValue(args)</span>
    <span class='types'>args === {x:#,y:#}</span>
    <span class='description'>Returns the Value of the noise according to the set output Parameters. Requires a Object with x and y keyvalues.</span>
    </div>
	</div>
</div>  

<div class='section' id='Simple3D'>
<div class='content-item'>
<pre title="Simple3D:"><xmp>var noise = new dN('Simple3' ,seed => string, args => {});
noise.getValue(args =>{});
</xmp></pre>
	This is the quickest to compute, and is based off of Stefan Gustavson Noise Calculations.
	</div>
    <hr />
    <h4>Arguments</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>frequency</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>frequency refers to the period or phase at which data is sampled.</span>
    </div>
    <div class='item'>
    <span class='title'>amplitude</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>amplitude refers to the range that the current octave at which the result can be in.</span>
    </div>
    <div class='item'>
    <span class='title'>octave</span>
    <span class='types'>oftype === int >= 1</span>
    <span class='description'>Each octave has less influence on the final result. Each octave adds a linear increase in code execution time, do not use more than a few octaves if not preprocessed.</span>
    </div>
    <div class='item'>
    <span class='title'>persistence</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>The influence should each successive octave have, quantitatively.</span>
    </div>
    <div class='item'>
    <span class='title'>scale</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>This will Multipy the x,y input on the ._getValue() method.  Effectivly sizing up the noise. *A scale of 1 is effectivly random noise</span>
    </div>
    <div class='item'>
    <span class='title'>scaleFloor</span>
    <span class='types'>oftype === bool</span>
    <span class='description'>Floors the scaling of the noise to whole numbers.  This is good for a pixlated look.</span>
    </div>
    <div class='item'>
    <span class='title'>output</span>
    <span class='types'>oftype === {type: oftype === (string => 'number' || 'color' ), values: oftype === (Array(4) => [0<=>1,0<=>1,0<=>1,0<=>1])}</span>
    <span class='description'>In order to change the output from a single value to a color you must include this object as and argument.  If you are simply returning a value do not worry about this argument.  If you do include it the value array is structured as R,G,B,A and their return value will be multiplied by the respective value.</span>
    </div>
    </div>
    <h4>Methods</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>._getValue(args)</span>
    <span class='types'>args === {x:#,y:#,z:#}</span>
    <span class='description'>Returns the Value of the noise according to the set output Parameters. Requires a Object with x, y and z keyvalues.</span>
    </div>
	</div>
</div>  

<div class='section' id='Perlin2D'>
<div class='content-item'>
<pre title="Perlin2D:"><xmp>var noise = new dN('Perlin2' ,seed => string, args => {});
noise.getValue(args =>{});
</xmp></pre>
	Based off of Stefan Gustavson Noise Calculations.
	</div>
    <hr />
    <h4>Arguments</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>frequency</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>frequency refers to the period or phase at which data is sampled.</span>
    </div>
    <div class='item'>
    <span class='title'>amplitude</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>amplitude refers to the range that the current octave at which the result can be in.</span>
    </div>
    <div class='item'>
    <span class='title'>octave</span>
    <span class='types'>oftype === int >= 1</span>
    <span class='description'>Each octave has less influence on the final result. Each octave adds a linear increase in code execution time, do not use more than a few octaves if not preprocessed.</span>
    </div>
    <div class='item'>
    <span class='title'>persistence</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>The influence should each successive octave have, quantitatively.</span>
    </div>
    <div class='item'>
    <span class='title'>scale</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>This will Multipy the x,y input on the ._getValue() method.  Effectivly sizing up the noise. *A scale of 10 is recomended for good output.</span>
    </div>
    <div class='item'>
    <span class='title'>scaleFloor</span>
    <span class='types'>oftype === bool</span>
    <span class='description'>Floors the scaling of the noise to whole numbers.  This is good for a pixlated look.</span>
    </div>
    <div class='item'>
    <span class='title'>output</span>
    <span class='types'>oftype === {type: oftype === (string => 'number' || 'color' ), values: oftype === (Array(4) => [0<=>1,0<=>1,0<=>1,0<=>1])}</span>
    <span class='description'>In order to change the output from a single value to a color you must include this object as and argument.  If you are simply returning a value do not worry about this argument.  If you do include it the value array is structured as R,G,B,A and their return value will be multiplied by the respective value.</span>
    </div>
    </div>
    <h4>Methods</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>._getValue(args)</span>
    <span class='types'>args === {x:#,y:#}</span>
    <span class='description'>Returns the Value of the noise according to the set output Parameters. Requires a Object with x and y keyvalues.</span>
    </div>
	</div>
</div>

<div class='section' id='Perlin3D'>
<div class='content-item'>
<pre title="Perlin3D:"><xmp>var noise = new dN('Perlin3' ,seed => string, args => {});
noise.getValue(args =>{});
</xmp></pre>
	Based off of Stefan Gustavson Noise Calculations.
	</div>
    <hr />
    <h4>Arguments</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>frequency</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>frequency refers to the period or phase at which data is sampled.</span>
    </div>
    <div class='item'>
    <span class='title'>amplitude</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>amplitude refers to the range that the current octave at which the result can be in.</span>
    </div>
    <div class='item'>
    <span class='title'>octave</span>
    <span class='types'>oftype === int >= 1</span>
    <span class='description'>Each octave has less influence on the final result. Each octave adds a linear increase in code execution time, do not use more than a few octaves if not preprocessed.</span>
    </div>
    <div class='item'>
    <span class='title'>persistence</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>The influence should each successive octave have, quantitatively.</span>
    </div>
    <div class='item'>
    <span class='title'>scale</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>This will Multipy the x,y input on the ._getValue() method.  Effectivly sizing up the noise. *A scale of 10 is recomended for good output.</span>
    </div>
    <div class='item'>
    <span class='title'>scaleFloor</span>
    <span class='types'>oftype === bool</span>
    <span class='description'>Floors the scaling of the noise to whole numbers.  This is good for a pixlated look.</span>
    </div>
    <div class='item'>
    <span class='title'>output</span>
    <span class='types'>oftype === {type: oftype === (string => 'number' || 'color' ), values: oftype === (Array(4) => [0<=>1,0<=>1,0<=>1,0<=>1])}</span>
    <span class='description'>In order to change the output from a single value to a color you must include this object as and argument.  If you are simply returning a value do not worry about this argument.  If you do include it the value array is structured as R,G,B,A and their return value will be multiplied by the respective value.</span>
    </div>
    </div>
    <h4>Methods</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>._getValue(args)</span>
    <span class='types'>args === {x:#,y:#,z:#}</span>
    <span class='description'>Returns the Value of the noise according to the set output Parameters. Requires a Object with x , y and z keyvalues.</span>
    </div>
	</div>
</div>    

<div class='section disabled' id='Poorly2D'>
<div class='content-item'>
<pre title="Poorly2D:"><xmp>var noise = new dN('Poorly2' ,seed => string, args => {});
noise.getValue(args =>{});
</xmp></pre>
	My janky version of worley noise, before I really did some research.  Produces some cool geometric effects.
	</div>
    <hr />
    <h4>Arguments</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>frequency</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>frequency refers to the period or phase at which data is sampled.</span>
    </div>
    <div class='item'>
    <span class='title'>amplitude</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>amplitude refers to the range that the current octave at which the result can be in.</span>
    </div>
    <div class='item'>
    <span class='title'>octave</span>
    <span class='types'>oftype === int >= 1</span>
    <span class='description'>Each octave has less influence on the final result. Each octave adds a linear increase in code execution time, do not use more than a few octaves if not preprocessed.</span>
    </div>
    <div class='item'>
    <span class='title'>persistence</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>The influence should each successive octave have, quantitatively.</span>
    </div>
    <div class='item'>
    <span class='title'>scale</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>This will Multipy the x,y input on the ._getValue() method.  Effectivly sizing up the noise. *A scale of 10 is recomended for good output.</span>
    </div>
    <div class='item'>
    <span class='title'>scaleFloor</span>
    <span class='types'>oftype === bool</span>
    <span class='description'>Floors the scaling of the noise to whole numbers.  This is good for a pixlated look.</span>
    </div>
    <div class='item'>
    <span class='title'>output</span>
    <span class='types'>oftype === {type: oftype === (string => 'number' || 'color' ), values: oftype === (Array(4) => [0<=>1,0<=>1,0<=>1,0<=>1])}</span>
    <span class='description'>In order to change the output from a single value to a color you must include this object as and argument.  If you are simply returning a value do not worry about this argument.  If you do include it the value array is structured as R,G,B,A and their return value will be multiplied by the respective value.</span>
    </div>
    </div>
    <h4>Methods</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>._getValue(args)</span>
    <span class='types'>args === {x:#,y:#</span>
    <span class='description'>Returns the Value of the noise according to the set output Parameters. Requires a Object with x and y keyvalues.</span>
    </div>
	</div>
</div>

<div class='section disabled' id='Tiley2D'>
<div class='content-item'>
<pre title="Poorly2D:"><xmp>var noise = new dN('Tiley2' ,seed => string, args => {});
noise.getValue(args =>{});
</xmp></pre>
	A Variation of my Poorly System, creates Tile like structures.  Will be adding a lot more functionality to this one.
	</div>
    <hr />
    <h4>Arguments</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>frequency</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>frequency refers to the period or phase at which data is sampled.</span>
    </div>
    <div class='item'>
    <span class='title'>amplitude</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>amplitude refers to the range that the current octave at which the result can be in.</span>
    </div>
    <div class='item'>
    <span class='title'>octave</span>
    <span class='types'>oftype === int >= 1</span>
    <span class='description'>Each octave has less influence on the final result. Each octave adds a linear increase in code execution time, do not use more than a few octaves if not preprocessed.</span>
    </div>
    <div class='item'>
    <span class='title'>persistence</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>The influence should each successive octave have, quantitatively.</span>
    </div>
    <div class='item'>
    <span class='title'>scale</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>This will Multipy the x,y input on the ._getValue() method.  Effectivly sizing up the noise. *A scale of 10 is recomended for good output.</span>
    </div>
    <div class='item'>
    <span class='title'>scaleFloor</span>
    <span class='types'>oftype === bool</span>
    <span class='description'>Floors the scaling of the noise to whole numbers.  This is good for a pixlated look.</span>
    </div>
    <div class='item'>
    <span class='title'>output</span>
    <span class='types'>oftype === {type: oftype === (string => 'number' || 'color' ), values: oftype === (Array(4) => [0<=>1,0<=>1,0<=>1,0<=>1])}</span>
    <span class='description'>In order to change the output from a single value to a color you must include this object as and argument.  If you are simply returning a value do not worry about this argument.  If you do include it the value array is structured as R,G,B,A and their return value will be multiplied by the respective value.</span>
    </div>
    </div>
    <h4>Methods</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>._getValue(args)</span>
    <span class='types'>args === {x:#,y:#</span>
    <span class='description'>Returns the Value of the noise according to the set output Parameters. Requires a Object with x and y keyvalues.</span>
    </div>
	</div>
</div>

<div class='section disabled' id='Worley2D'>
<div class='content-item'>
<pre title="Worley2D:"><xmp>var noise = new dN('Worley2' ,seed => string, args => {});
noise.getValue(args =>{});
</xmp></pre>
	My Variation of a Classic Cellular System.  As seen in <a href='./tutorial_1' target="_blank">Tutorial 1</a>.
	</div>
    <hr />
    <h4>Arguments</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>frequency</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>frequency refers to the period or phase at which data is sampled.</span>
    </div>
    <div class='item'>
    <span class='title'>amplitude</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>amplitude refers to the range that the current octave at which the result can be in.</span>
    </div>
    <div class='item'>
    <span class='title'>octave</span>
    <span class='types'>oftype === int >= 1</span>
    <span class='description'>Each octave has less influence on the final result. Each octave adds a linear increase in code execution time, do not use more than a few octaves if not preprocessed.</span>
    </div>
    <div class='item'>
    <span class='title'>persistence</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>The influence should each successive octave have, quantitatively.</span>
    </div>
    <div class='item'>
    <span class='title'>scale</span>
    <span class='types'>oftype === number > 0</span>
    <span class='description'>This will Multipy the x,y input on the ._getValue() method.  Effectivly sizing up the noise. *A scale of 10 is recomended for good output.</span>
    </div>
    <div class='item'>
    <span class='title'>scaleFloor</span>
    <span class='types'>oftype === bool</span>
    <span class='description'>Floors the scaling of the noise to whole numbers.  This is good for a pixlated look.</span>
    </div>
    <div class='item'>
    <span class='title'>output</span>
    <span class='types'>oftype === {type: oftype === (string => 'number' || 'color' ), values: oftype === (Array(4) => [0<=>1,0<=>1,0<=>1,0<=>1])}</span>
    <span class='description'>In order to change the output from a single value to a color you must include this object as and argument.  If you are simply returning a value do not worry about this argument.  If you do include it the value array is structured as R,G,B,A and their return value will be multiplied by the respective value.</span>
    </div>
    </div>
    <h4>Methods</h4>
    <div class='content-item'>
    <div class='item'>
    <span class='title'>._getValue(args)</span>
    <span class='types'>args === {x:#,y:#</span>
    <span class='description'>Returns the Value of the noise according to the set output Parameters. Requires a Object with x and y keyvalues.</span>
    </div>
	</div>
</div>  

</div>
</div>

<hr />
<div class='section' id='tutorials'>
Also I will be posting tutorials on this website dealing with the development of noises and their uses.  Be Sure to check out the first in the serise!
<BR />
<ul>
<li><a href='./Tutorial_1/' target="_blank">LETS MAKE SOME NOISE!</a></li>
</ul>
</div>


<BR />
<div class='footer'><span class='credits'>2016 Andrew V Butt Sr. aka <a href='mailto:Pryme8@gmail.com'>Pryme8</a></span></div>
</div>
</div>
</div>
</div>
<script>
$(function(){
	$('.left-menu .menu a').click(function(e){
		var t = $(e.target).attr('href');
		$('.menu-section .active').removeClass('active');
		$('.section'+t).addClass('active');	
			
	});
	
	function getHash(){
	var url = window.location.href;
	var hash = url.substring(url.indexOf("#")+1);
	if(typeof hash !== 'undefined' || hash != ''){
		var t = $('.left-menu .menu a[href="#'+hash+'"]');
		if(t.length){
			$('.menu-section .active').removeClass('active');
			$('.section'+t.attr('href')).addClass('active');	
		}else{
		var offset = $("#"+hash).offset().top;
		$('.wrap-fix').animate({scrollTop:offset}, 1500, 'easeInSine');
		}
	}
	}
	
	getHash();
	window.onhashchange = getHash;
	
});
</script>
</body>
</html>
